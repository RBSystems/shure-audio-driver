package event

import (
	"fmt"
	"regexp"
	"strconv"
	"strings"

	"github.com/byuoitav/common/v2/events"
)

const (
	// interference states
	infNone     = "NONE"
	infCritical = "CRITICAL"

	//power states
	pStandBy = "UNKN"

	//battery states
	bCycle   = "BATT_CYCLE"
	bRunTime = "BATT_RUN_TIME"
	bType    = "BATT_TYPE"
	bCharge  = "BATT_CHARGE"
	bBars    = "BATT_BARS"

	flag = "ignored"
)

type shureEvent struct {
	Type       state
	DeviceName string
	E          *events.Event
}

func (e *shureEvent) SetEventType(resp string) {
	if strings.Contains(resp, interference.String()) {
		e.Type = interference
	} else if strings.Contains(resp, power.String()) {
		e.Type = power
	} else if strings.Contains(resp, battery.String()) {
		e.Type = battery
	} else {
		e.Type = unknown
	}
}

func (e *shureEvent) FillEventInfo(resp string) {
	var err error
	if e.Type == interference {
		err = fillInterference(resp, e.E)
	} else if e.Type == power {
		err = fillPower(resp, e.E)
	} else if e.Type == battery {
		err = fillBattery(resp, e.E)
	} else {
		// this should never be reached
	}

	if err != nil {

	}
}

func fillInterference(resp string, event *events.Event) error {
	event.Key = "interference"
	event.AddToTags(events.AutoGenerated)

	if strings.Contains(resp, infNone) {
		event.Value = infNone
		event.AddToTags(events.DetailState)
	} else if strings.Contains(resp, infCritical) {
		event.Value = infCritical
		event.AddToTags(events.Error)
	} else {
		return fmt.Errorf("invalid interference response")
	}
	return nil
}

func fillPower(resp string, event *events.Event) error {
	event.Key = "power"
	event.AddToTags(events.CoreState)

	if strings.Contains(resp, pStandBy) {
		event.Value = "standby"
		event.AddToTags(events.AutoGenerated)
	} else {
		event.Value = "on"
		event.AddToTags(events.StartUp)
	}

	return nil
}

func fillBattery(resp string, event *events.Event) error {

	event.AddToTags(events.AutoGenerated)
	event.AddToTags(events.DetailState)

	if strings.Contains(resp, bCycle) {

		event.Key = "battery-cycles"
		re := regexp.MustCompile("[1-9][0-9]*")
		batteryCycles := re.FindString(resp)

		switch batteryCycles {
		case "65535":
			event.Value = flag
		case "":
			event.Value = "0"
		default:
			event.Value = batteryCycles
		}

	} else if strings.Contains(resp, bRunTime) {

		event.Key = "battery-charge-minutes"
		re := regexp.MustCompile("[1-9][0-9]*")
		runTime := re.FindString(resp)

		switch runTime {
		case "65535":
			event.Value = flag
		case "65534":
			event.Value = "calculating"
		case "":
			event.Value = "0"
		default:
			event.Value = runTime
		}

	} else if strings.Contains(resp, bType) {

		event.Key = "battery-type"

		re := regexp.MustCompile("[\\s][A-Z]{4}[\\s]")
		batteryType := re.FindString(resp)

		if batteryType == " UNKN " {
			event.Value = "Unknown"
		} else {
			event.Value = batteryType[1 : len(batteryType)-1]
		}

	} else if strings.Contains(resp, bCharge) {

		event.Key = "battery-charge-percentage"
		re := regexp.MustCompile("[1-9][0-9]*")
		value := re.FindString(resp)
		percentage, err := strconv.Atoi(value)
		if err != nil {
			return err
		}

		switch percentage {
		case 255:
			event.Value = flag
		case 254:
			event.Value = "calculating"
		default:
			event.Value = value
		}

	} else if strings.Contains(resp, bBars) {

		event.Key = "battery-charge-bars"
		re := regexp.MustCompile("[1-9][0-9]*")
		value := re.FindString(resp)

		bars, err := strconv.Atoi(value)
		if err != nil {
			return err
		}

		switch bars {
		case 255:
			event.Value = flag
		case 254:
			event.Value = "calculating"
		default:
			event.Value = value
		}

	} else {
		event.Value = flag
	}

	return nil
}
