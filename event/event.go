package event

import (
	"regexp"
	"strconv"
	"strings"

	"github.com/byuoitav/common/v2/events"
	"github.com/byuoitav/shure-audio-driver/log"
	"go.uber.org/zap"
)

const (
	// interference states
	infNone     = "NONE"
	infCritical = "CRITICAL"

	//power states
	pStandBy = "UNKN"

	//battery states
	bCycle   = "BATT_CYCLE"
	bRunTime = "BATT_RUN_TIME"
	bType    = "BATT_TYPE"
	bCharge  = "BATT_CHARGE"
	bBars    = "BATT_BARS"

	IGNORE = "ignored"
)

type ShureEvent struct {
	Type state
	E    *events.Event
}

func (e *ShureEvent) SetEventType(resp string) {
	if strings.Contains(resp, Interference.String()) {
		e.Type = Interference
	} else if strings.Contains(resp, Power.String()) {
		e.Type = Power
	} else if strings.Contains(resp, Battery.String()) {
		e.Type = Battery
	} else {
		e.Type = Unknown
	}
}

func (e *ShureEvent) FillEventInfo(resp string) {
	var err error
	if e.Type == Interference {
		err = fillInterference(resp, e.E)
	} else if e.Type == Power {
		err = fillPower(resp, e.E)
	} else if e.Type == Battery {
		err = fillBattery(resp, e.E)
	} else {
		// type is unknown
		e.E.Value = IGNORE
	}

	if err != nil {
		e.E.Value = IGNORE
		log.L.Error("failure when filling event info", zap.Error(err))
	}
}

func fillInterference(resp string, event *events.Event) error {
	event.Key = "interference"
	event.AddToTags(events.AutoGenerated)

	if strings.Contains(resp, infNone) {
		event.Value = infNone
		event.AddToTags(events.DetailState)
	} else if strings.Contains(resp, infCritical) {
		event.Value = infCritical
		event.AddToTags(events.Error)
	} else {
		event.Value = IGNORE
	}
	return nil
}

func fillPower(resp string, event *events.Event) error {
	event.Key = "power"
	event.AddToTags(events.CoreState)

	if strings.Contains(resp, pStandBy) {
		event.Value = "standby"
		event.AddToTags(events.AutoGenerated)
	} else {
		event.Value = "on"
		event.AddToTags(events.StartUp)
	}
	return nil
}

func fillBattery(resp string, event *events.Event) error {
	event.AddToTags(events.AutoGenerated)
	event.AddToTags(events.DetailState)

	if strings.Contains(resp, bCycle) {

		event.Key = "battery-cycles"
		re := regexp.MustCompile("[1-9][0-9]*")
		batteryCycles := re.FindString(resp)

		switch batteryCycles {
		case "65535":
			event.Value = IGNORE
		case "":
			event.Value = "0"
		default:
			event.Value = batteryCycles
		}

	} else if strings.Contains(resp, bRunTime) {

		event.Key = "battery-charge-minutes"
		re := regexp.MustCompile("[1-9][0-9]*")
		runTime := re.FindString(resp)

		switch runTime {
		case "65535":
			event.Value = IGNORE
		case "65534":
			event.Value = "calculating"
		case "":
			event.Value = "0"
		default:
			event.Value = runTime
		}

	} else if strings.Contains(resp, bType) {

		event.Key = "battery-type"

		re := regexp.MustCompile("[\\s][A-Z]{4}[\\s]")
		batteryType := re.FindString(resp)

		if batteryType == " UNKN " {
			event.Value = "Unknown"
		} else {
			event.Value = batteryType[1 : len(batteryType)-1]
		}

	} else if strings.Contains(resp, bCharge) {

		event.Key = "battery-charge-percentage"
		re := regexp.MustCompile("[1-9][0-9]*")
		value := re.FindString(resp)
		percentage, err := strconv.Atoi(value)
		if err != nil {
			return err
		}

		switch percentage {
		case 255:
			event.Value = IGNORE
		case 254:
			event.Value = "calculating"
		default:
			event.Value = value
		}

	} else if strings.Contains(resp, bBars) {

		event.Key = "battery-charge-bars"
		re := regexp.MustCompile("[1-9][0-9]*")
		value := re.FindString(resp)

		bars, err := strconv.Atoi(value)
		if err != nil {
			return err
		}

		switch bars {
		case 255:
			event.Value = IGNORE
		case 254:
			event.Value = "calculating"
		default:
			event.Value = value
		}

	} else {
		event.Value = IGNORE
	}

	return nil
}
